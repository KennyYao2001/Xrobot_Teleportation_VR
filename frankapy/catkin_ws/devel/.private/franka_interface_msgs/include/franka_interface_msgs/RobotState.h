// Generated by gencpp from file franka_interface_msgs/RobotState.msg
// DO NOT EDIT!


#ifndef FRANKA_INTERFACE_MSGS_MESSAGE_ROBOTSTATE_H
#define FRANKA_INTERFACE_MSGS_MESSAGE_ROBOTSTATE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <franka_interface_msgs/Errors.h>
#include <franka_interface_msgs/Errors.h>

namespace franka_interface_msgs
{
template <class ContainerAllocator>
struct RobotState_
{
  typedef RobotState_<ContainerAllocator> Type;

  RobotState_()
    : header()
    , pose_desired()
    , O_T_EE()
    , O_T_EE_d()
    , F_T_EE()
    , EE_T_K()
    , m_ee(0.0)
    , I_ee()
    , F_x_Cee()
    , m_load(0.0)
    , I_load()
    , F_x_Cload()
    , m_total(0.0)
    , I_total()
    , F_x_Ctotal()
    , elbow()
    , elbow_d()
    , elbow_c()
    , delbow_c()
    , ddelbow_c()
    , tau_J()
    , tau_J_d()
    , dtau_J()
    , q()
    , q_d()
    , dq()
    , dq_d()
    , ddq_d()
    , joint_contact()
    , cartesian_contact()
    , joint_collision()
    , cartesian_collision()
    , tau_ext_hat_filtered()
    , O_F_ext_hat_K()
    , K_F_ext_hat_K()
    , O_dP_EE_d()
    , O_T_EE_c()
    , O_dP_EE_c()
    , O_ddP_EE_c()
    , theta()
    , dtheta()
    , current_errors()
    , last_motion_errors()
    , control_command_success_rate(0.0)
    , robot_mode(0)
    , robot_time(0.0)
    , gripper_width(0.0)
    , gripper_max_width(0.0)
    , gripper_is_grasped(false)
    , gripper_temperature(0)
    , gripper_time(0.0)
    , is_fresh(false)  {
      pose_desired.assign(0.0);

      O_T_EE.assign(0.0);

      O_T_EE_d.assign(0.0);

      F_T_EE.assign(0.0);

      EE_T_K.assign(0.0);

      I_ee.assign(0.0);

      F_x_Cee.assign(0.0);

      I_load.assign(0.0);

      F_x_Cload.assign(0.0);

      I_total.assign(0.0);

      F_x_Ctotal.assign(0.0);

      elbow.assign(0.0);

      elbow_d.assign(0.0);

      elbow_c.assign(0.0);

      delbow_c.assign(0.0);

      ddelbow_c.assign(0.0);

      tau_J.assign(0.0);

      tau_J_d.assign(0.0);

      dtau_J.assign(0.0);

      q.assign(0.0);

      q_d.assign(0.0);

      dq.assign(0.0);

      dq_d.assign(0.0);

      ddq_d.assign(0.0);

      joint_contact.assign(0.0);

      cartesian_contact.assign(0.0);

      joint_collision.assign(0.0);

      cartesian_collision.assign(0.0);

      tau_ext_hat_filtered.assign(0.0);

      O_F_ext_hat_K.assign(0.0);

      K_F_ext_hat_K.assign(0.0);

      O_dP_EE_d.assign(0.0);

      O_T_EE_c.assign(0.0);

      O_dP_EE_c.assign(0.0);

      O_ddP_EE_c.assign(0.0);

      theta.assign(0.0);

      dtheta.assign(0.0);
  }
  RobotState_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , pose_desired()
    , O_T_EE()
    , O_T_EE_d()
    , F_T_EE()
    , EE_T_K()
    , m_ee(0.0)
    , I_ee()
    , F_x_Cee()
    , m_load(0.0)
    , I_load()
    , F_x_Cload()
    , m_total(0.0)
    , I_total()
    , F_x_Ctotal()
    , elbow()
    , elbow_d()
    , elbow_c()
    , delbow_c()
    , ddelbow_c()
    , tau_J()
    , tau_J_d()
    , dtau_J()
    , q()
    , q_d()
    , dq()
    , dq_d()
    , ddq_d()
    , joint_contact()
    , cartesian_contact()
    , joint_collision()
    , cartesian_collision()
    , tau_ext_hat_filtered()
    , O_F_ext_hat_K()
    , K_F_ext_hat_K()
    , O_dP_EE_d()
    , O_T_EE_c()
    , O_dP_EE_c()
    , O_ddP_EE_c()
    , theta()
    , dtheta()
    , current_errors(_alloc)
    , last_motion_errors(_alloc)
    , control_command_success_rate(0.0)
    , robot_mode(0)
    , robot_time(0.0)
    , gripper_width(0.0)
    , gripper_max_width(0.0)
    , gripper_is_grasped(false)
    , gripper_temperature(0)
    , gripper_time(0.0)
    , is_fresh(false)  {
  (void)_alloc;
      pose_desired.assign(0.0);

      O_T_EE.assign(0.0);

      O_T_EE_d.assign(0.0);

      F_T_EE.assign(0.0);

      EE_T_K.assign(0.0);

      I_ee.assign(0.0);

      F_x_Cee.assign(0.0);

      I_load.assign(0.0);

      F_x_Cload.assign(0.0);

      I_total.assign(0.0);

      F_x_Ctotal.assign(0.0);

      elbow.assign(0.0);

      elbow_d.assign(0.0);

      elbow_c.assign(0.0);

      delbow_c.assign(0.0);

      ddelbow_c.assign(0.0);

      tau_J.assign(0.0);

      tau_J_d.assign(0.0);

      dtau_J.assign(0.0);

      q.assign(0.0);

      q_d.assign(0.0);

      dq.assign(0.0);

      dq_d.assign(0.0);

      ddq_d.assign(0.0);

      joint_contact.assign(0.0);

      cartesian_contact.assign(0.0);

      joint_collision.assign(0.0);

      cartesian_collision.assign(0.0);

      tau_ext_hat_filtered.assign(0.0);

      O_F_ext_hat_K.assign(0.0);

      K_F_ext_hat_K.assign(0.0);

      O_dP_EE_d.assign(0.0);

      O_T_EE_c.assign(0.0);

      O_dP_EE_c.assign(0.0);

      O_ddP_EE_c.assign(0.0);

      theta.assign(0.0);

      dtheta.assign(0.0);
  }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef boost::array<double, 16>  _pose_desired_type;
  _pose_desired_type pose_desired;

   typedef boost::array<double, 16>  _O_T_EE_type;
  _O_T_EE_type O_T_EE;

   typedef boost::array<double, 16>  _O_T_EE_d_type;
  _O_T_EE_d_type O_T_EE_d;

   typedef boost::array<double, 16>  _F_T_EE_type;
  _F_T_EE_type F_T_EE;

   typedef boost::array<double, 16>  _EE_T_K_type;
  _EE_T_K_type EE_T_K;

   typedef double _m_ee_type;
  _m_ee_type m_ee;

   typedef boost::array<double, 9>  _I_ee_type;
  _I_ee_type I_ee;

   typedef boost::array<double, 3>  _F_x_Cee_type;
  _F_x_Cee_type F_x_Cee;

   typedef double _m_load_type;
  _m_load_type m_load;

   typedef boost::array<double, 9>  _I_load_type;
  _I_load_type I_load;

   typedef boost::array<double, 3>  _F_x_Cload_type;
  _F_x_Cload_type F_x_Cload;

   typedef double _m_total_type;
  _m_total_type m_total;

   typedef boost::array<double, 9>  _I_total_type;
  _I_total_type I_total;

   typedef boost::array<double, 3>  _F_x_Ctotal_type;
  _F_x_Ctotal_type F_x_Ctotal;

   typedef boost::array<double, 2>  _elbow_type;
  _elbow_type elbow;

   typedef boost::array<double, 2>  _elbow_d_type;
  _elbow_d_type elbow_d;

   typedef boost::array<double, 2>  _elbow_c_type;
  _elbow_c_type elbow_c;

   typedef boost::array<double, 2>  _delbow_c_type;
  _delbow_c_type delbow_c;

   typedef boost::array<double, 2>  _ddelbow_c_type;
  _ddelbow_c_type ddelbow_c;

   typedef boost::array<double, 7>  _tau_J_type;
  _tau_J_type tau_J;

   typedef boost::array<double, 7>  _tau_J_d_type;
  _tau_J_d_type tau_J_d;

   typedef boost::array<double, 7>  _dtau_J_type;
  _dtau_J_type dtau_J;

   typedef boost::array<double, 7>  _q_type;
  _q_type q;

   typedef boost::array<double, 7>  _q_d_type;
  _q_d_type q_d;

   typedef boost::array<double, 7>  _dq_type;
  _dq_type dq;

   typedef boost::array<double, 7>  _dq_d_type;
  _dq_d_type dq_d;

   typedef boost::array<double, 7>  _ddq_d_type;
  _ddq_d_type ddq_d;

   typedef boost::array<double, 7>  _joint_contact_type;
  _joint_contact_type joint_contact;

   typedef boost::array<double, 6>  _cartesian_contact_type;
  _cartesian_contact_type cartesian_contact;

   typedef boost::array<double, 7>  _joint_collision_type;
  _joint_collision_type joint_collision;

   typedef boost::array<double, 6>  _cartesian_collision_type;
  _cartesian_collision_type cartesian_collision;

   typedef boost::array<double, 7>  _tau_ext_hat_filtered_type;
  _tau_ext_hat_filtered_type tau_ext_hat_filtered;

   typedef boost::array<double, 6>  _O_F_ext_hat_K_type;
  _O_F_ext_hat_K_type O_F_ext_hat_K;

   typedef boost::array<double, 6>  _K_F_ext_hat_K_type;
  _K_F_ext_hat_K_type K_F_ext_hat_K;

   typedef boost::array<double, 6>  _O_dP_EE_d_type;
  _O_dP_EE_d_type O_dP_EE_d;

   typedef boost::array<double, 16>  _O_T_EE_c_type;
  _O_T_EE_c_type O_T_EE_c;

   typedef boost::array<double, 6>  _O_dP_EE_c_type;
  _O_dP_EE_c_type O_dP_EE_c;

   typedef boost::array<double, 6>  _O_ddP_EE_c_type;
  _O_ddP_EE_c_type O_ddP_EE_c;

   typedef boost::array<double, 7>  _theta_type;
  _theta_type theta;

   typedef boost::array<double, 7>  _dtheta_type;
  _dtheta_type dtheta;

   typedef  ::franka_interface_msgs::Errors_<ContainerAllocator>  _current_errors_type;
  _current_errors_type current_errors;

   typedef  ::franka_interface_msgs::Errors_<ContainerAllocator>  _last_motion_errors_type;
  _last_motion_errors_type last_motion_errors;

   typedef double _control_command_success_rate_type;
  _control_command_success_rate_type control_command_success_rate;

   typedef uint8_t _robot_mode_type;
  _robot_mode_type robot_mode;

   typedef double _robot_time_type;
  _robot_time_type robot_time;

   typedef double _gripper_width_type;
  _gripper_width_type gripper_width;

   typedef double _gripper_max_width_type;
  _gripper_max_width_type gripper_max_width;

   typedef uint8_t _gripper_is_grasped_type;
  _gripper_is_grasped_type gripper_is_grasped;

   typedef uint16_t _gripper_temperature_type;
  _gripper_temperature_type gripper_temperature;

   typedef double _gripper_time_type;
  _gripper_time_type gripper_time;

   typedef uint8_t _is_fresh_type;
  _is_fresh_type is_fresh;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(ROBOT_MODE_OTHER)
  #undef ROBOT_MODE_OTHER
#endif
#if defined(_WIN32) && defined(ROBOT_MODE_IDLE)
  #undef ROBOT_MODE_IDLE
#endif
#if defined(_WIN32) && defined(ROBOT_MODE_MOVE)
  #undef ROBOT_MODE_MOVE
#endif
#if defined(_WIN32) && defined(ROBOT_MODE_GUIDING)
  #undef ROBOT_MODE_GUIDING
#endif
#if defined(_WIN32) && defined(ROBOT_MODE_REFLEX)
  #undef ROBOT_MODE_REFLEX
#endif
#if defined(_WIN32) && defined(ROBOT_MODE_USER_STOPPED)
  #undef ROBOT_MODE_USER_STOPPED
#endif
#if defined(_WIN32) && defined(ROBOT_MODE_AUTOMATIC_ERROR_RECOVERY)
  #undef ROBOT_MODE_AUTOMATIC_ERROR_RECOVERY
#endif

  enum {
    ROBOT_MODE_OTHER = 0u,
    ROBOT_MODE_IDLE = 1u,
    ROBOT_MODE_MOVE = 2u,
    ROBOT_MODE_GUIDING = 3u,
    ROBOT_MODE_REFLEX = 4u,
    ROBOT_MODE_USER_STOPPED = 5u,
    ROBOT_MODE_AUTOMATIC_ERROR_RECOVERY = 6u,
  };


  typedef boost::shared_ptr< ::franka_interface_msgs::RobotState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::franka_interface_msgs::RobotState_<ContainerAllocator> const> ConstPtr;

}; // struct RobotState_

typedef ::franka_interface_msgs::RobotState_<std::allocator<void> > RobotState;

typedef boost::shared_ptr< ::franka_interface_msgs::RobotState > RobotStatePtr;
typedef boost::shared_ptr< ::franka_interface_msgs::RobotState const> RobotStateConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::franka_interface_msgs::RobotState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::franka_interface_msgs::RobotState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::franka_interface_msgs::RobotState_<ContainerAllocator1> & lhs, const ::franka_interface_msgs::RobotState_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.pose_desired == rhs.pose_desired &&
    lhs.O_T_EE == rhs.O_T_EE &&
    lhs.O_T_EE_d == rhs.O_T_EE_d &&
    lhs.F_T_EE == rhs.F_T_EE &&
    lhs.EE_T_K == rhs.EE_T_K &&
    lhs.m_ee == rhs.m_ee &&
    lhs.I_ee == rhs.I_ee &&
    lhs.F_x_Cee == rhs.F_x_Cee &&
    lhs.m_load == rhs.m_load &&
    lhs.I_load == rhs.I_load &&
    lhs.F_x_Cload == rhs.F_x_Cload &&
    lhs.m_total == rhs.m_total &&
    lhs.I_total == rhs.I_total &&
    lhs.F_x_Ctotal == rhs.F_x_Ctotal &&
    lhs.elbow == rhs.elbow &&
    lhs.elbow_d == rhs.elbow_d &&
    lhs.elbow_c == rhs.elbow_c &&
    lhs.delbow_c == rhs.delbow_c &&
    lhs.ddelbow_c == rhs.ddelbow_c &&
    lhs.tau_J == rhs.tau_J &&
    lhs.tau_J_d == rhs.tau_J_d &&
    lhs.dtau_J == rhs.dtau_J &&
    lhs.q == rhs.q &&
    lhs.q_d == rhs.q_d &&
    lhs.dq == rhs.dq &&
    lhs.dq_d == rhs.dq_d &&
    lhs.ddq_d == rhs.ddq_d &&
    lhs.joint_contact == rhs.joint_contact &&
    lhs.cartesian_contact == rhs.cartesian_contact &&
    lhs.joint_collision == rhs.joint_collision &&
    lhs.cartesian_collision == rhs.cartesian_collision &&
    lhs.tau_ext_hat_filtered == rhs.tau_ext_hat_filtered &&
    lhs.O_F_ext_hat_K == rhs.O_F_ext_hat_K &&
    lhs.K_F_ext_hat_K == rhs.K_F_ext_hat_K &&
    lhs.O_dP_EE_d == rhs.O_dP_EE_d &&
    lhs.O_T_EE_c == rhs.O_T_EE_c &&
    lhs.O_dP_EE_c == rhs.O_dP_EE_c &&
    lhs.O_ddP_EE_c == rhs.O_ddP_EE_c &&
    lhs.theta == rhs.theta &&
    lhs.dtheta == rhs.dtheta &&
    lhs.current_errors == rhs.current_errors &&
    lhs.last_motion_errors == rhs.last_motion_errors &&
    lhs.control_command_success_rate == rhs.control_command_success_rate &&
    lhs.robot_mode == rhs.robot_mode &&
    lhs.robot_time == rhs.robot_time &&
    lhs.gripper_width == rhs.gripper_width &&
    lhs.gripper_max_width == rhs.gripper_max_width &&
    lhs.gripper_is_grasped == rhs.gripper_is_grasped &&
    lhs.gripper_temperature == rhs.gripper_temperature &&
    lhs.gripper_time == rhs.gripper_time &&
    lhs.is_fresh == rhs.is_fresh;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::franka_interface_msgs::RobotState_<ContainerAllocator1> & lhs, const ::franka_interface_msgs::RobotState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace franka_interface_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::franka_interface_msgs::RobotState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::franka_interface_msgs::RobotState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::franka_interface_msgs::RobotState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::franka_interface_msgs::RobotState_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::franka_interface_msgs::RobotState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::franka_interface_msgs::RobotState_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::franka_interface_msgs::RobotState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "1bd13b23161f53b273eafd78a98128f7";
  }

  static const char* value(const ::franka_interface_msgs::RobotState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x1bd13b23161f53b2ULL;
  static const uint64_t static_value2 = 0x73eafd78a98128f7ULL;
};

template<class ContainerAllocator>
struct DataType< ::franka_interface_msgs::RobotState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "franka_interface_msgs/RobotState";
  }

  static const char* value(const ::franka_interface_msgs::RobotState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::franka_interface_msgs::RobotState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Franka robot state\n"
"# For more information about each field, look at robot_state.h here: \n"
"# https://github.com/frankaemika/libfranka/blob/master/include/franka/robot_state.h\n"
"std_msgs/Header header\n"
"float64[16] pose_desired\n"
"float64[16] O_T_EE \n"
"float64[16] O_T_EE_d\n"
"float64[16] F_T_EE\n"
"float64[16] EE_T_K\n"
"float64 m_ee\n"
"float64[9] I_ee\n"
"float64[3] F_x_Cee\n"
"float64 m_load\n"
"float64[9] I_load\n"
"float64[3] F_x_Cload\n"
"float64 m_total\n"
"float64[9] I_total\n"
"float64[3] F_x_Ctotal\n"
"float64[2] elbow\n"
"float64[2] elbow_d\n"
"float64[2] elbow_c\n"
"float64[2] delbow_c\n"
"float64[2] ddelbow_c\n"
"float64[7] tau_J\n"
"float64[7] tau_J_d\n"
"float64[7] dtau_J\n"
"float64[7] q\n"
"float64[7] q_d\n"
"float64[7] dq\n"
"float64[7] dq_d\n"
"float64[7] ddq_d\n"
"float64[7] joint_contact\n"
"float64[6] cartesian_contact\n"
"float64[7] joint_collision\n"
"float64[6] cartesian_collision\n"
"float64[7] tau_ext_hat_filtered\n"
"float64[6] O_F_ext_hat_K\n"
"float64[6] K_F_ext_hat_K\n"
"float64[6] O_dP_EE_d\n"
"float64[16] O_T_EE_c\n"
"float64[6] O_dP_EE_c\n"
"float64[6] O_ddP_EE_c\n"
"float64[7] theta\n"
"float64[7] dtheta\n"
"Errors current_errors\n"
"Errors last_motion_errors\n"
"float64 control_command_success_rate\n"
"uint8 ROBOT_MODE_OTHER=0\n"
"uint8 ROBOT_MODE_IDLE=1\n"
"uint8 ROBOT_MODE_MOVE=2\n"
"uint8 ROBOT_MODE_GUIDING=3\n"
"uint8 ROBOT_MODE_REFLEX=4\n"
"uint8 ROBOT_MODE_USER_STOPPED=5\n"
"uint8 ROBOT_MODE_AUTOMATIC_ERROR_RECOVERY=6\n"
"uint8 robot_mode\n"
"float64 robot_time\n"
"float64 gripper_width\n"
"float64 gripper_max_width\n"
"bool gripper_is_grasped\n"
"uint16 gripper_temperature\n"
"float64 gripper_time\n"
"bool is_fresh\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
"\n"
"================================================================================\n"
"MSG: franka_interface_msgs/Errors\n"
"bool joint_position_limits_violation\n"
"bool cartesian_position_limits_violation\n"
"bool self_collision_avoidance_violation\n"
"bool joint_velocity_violation\n"
"bool cartesian_velocity_violation\n"
"bool force_control_safety_violation\n"
"bool joint_reflex\n"
"bool cartesian_reflex\n"
"bool max_goal_pose_deviation_violation\n"
"bool max_path_pose_deviation_violation\n"
"bool cartesian_velocity_profile_safety_violation\n"
"bool joint_position_motion_generator_start_pose_invalid\n"
"bool joint_motion_generator_position_limits_violation\n"
"bool joint_motion_generator_velocity_limits_violation\n"
"bool joint_motion_generator_velocity_discontinuity\n"
"bool joint_motion_generator_acceleration_discontinuity\n"
"bool cartesian_position_motion_generator_start_pose_invalid\n"
"bool cartesian_motion_generator_elbow_limit_violation\n"
"bool cartesian_motion_generator_velocity_limits_violation\n"
"bool cartesian_motion_generator_velocity_discontinuity\n"
"bool cartesian_motion_generator_acceleration_discontinuity\n"
"bool cartesian_motion_generator_elbow_sign_inconsistent\n"
"bool cartesian_motion_generator_start_elbow_invalid\n"
"bool cartesian_motion_generator_joint_position_limits_violation\n"
"bool cartesian_motion_generator_joint_velocity_limits_violation\n"
"bool cartesian_motion_generator_joint_velocity_discontinuity\n"
"bool cartesian_motion_generator_joint_acceleration_discontinuity\n"
"bool cartesian_position_motion_generator_invalid_frame\n"
"bool force_controller_desired_force_tolerance_violation\n"
"bool controller_torque_discontinuity\n"
"bool start_elbow_sign_inconsistent\n"
"bool communication_constraints_violation\n"
"bool power_limit_violation\n"
"bool joint_p2p_insufficient_torque_for_planning\n"
"bool tau_j_range_violation\n"
"bool instability_detected\n"
"bool joint_move_in_wrong_direction\n"
;
  }

  static const char* value(const ::franka_interface_msgs::RobotState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::franka_interface_msgs::RobotState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.pose_desired);
      stream.next(m.O_T_EE);
      stream.next(m.O_T_EE_d);
      stream.next(m.F_T_EE);
      stream.next(m.EE_T_K);
      stream.next(m.m_ee);
      stream.next(m.I_ee);
      stream.next(m.F_x_Cee);
      stream.next(m.m_load);
      stream.next(m.I_load);
      stream.next(m.F_x_Cload);
      stream.next(m.m_total);
      stream.next(m.I_total);
      stream.next(m.F_x_Ctotal);
      stream.next(m.elbow);
      stream.next(m.elbow_d);
      stream.next(m.elbow_c);
      stream.next(m.delbow_c);
      stream.next(m.ddelbow_c);
      stream.next(m.tau_J);
      stream.next(m.tau_J_d);
      stream.next(m.dtau_J);
      stream.next(m.q);
      stream.next(m.q_d);
      stream.next(m.dq);
      stream.next(m.dq_d);
      stream.next(m.ddq_d);
      stream.next(m.joint_contact);
      stream.next(m.cartesian_contact);
      stream.next(m.joint_collision);
      stream.next(m.cartesian_collision);
      stream.next(m.tau_ext_hat_filtered);
      stream.next(m.O_F_ext_hat_K);
      stream.next(m.K_F_ext_hat_K);
      stream.next(m.O_dP_EE_d);
      stream.next(m.O_T_EE_c);
      stream.next(m.O_dP_EE_c);
      stream.next(m.O_ddP_EE_c);
      stream.next(m.theta);
      stream.next(m.dtheta);
      stream.next(m.current_errors);
      stream.next(m.last_motion_errors);
      stream.next(m.control_command_success_rate);
      stream.next(m.robot_mode);
      stream.next(m.robot_time);
      stream.next(m.gripper_width);
      stream.next(m.gripper_max_width);
      stream.next(m.gripper_is_grasped);
      stream.next(m.gripper_temperature);
      stream.next(m.gripper_time);
      stream.next(m.is_fresh);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RobotState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::franka_interface_msgs::RobotState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::franka_interface_msgs::RobotState_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "pose_desired[]" << std::endl;
    for (size_t i = 0; i < v.pose_desired.size(); ++i)
    {
      s << indent << "  pose_desired[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pose_desired[i]);
    }
    s << indent << "O_T_EE[]" << std::endl;
    for (size_t i = 0; i < v.O_T_EE.size(); ++i)
    {
      s << indent << "  O_T_EE[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.O_T_EE[i]);
    }
    s << indent << "O_T_EE_d[]" << std::endl;
    for (size_t i = 0; i < v.O_T_EE_d.size(); ++i)
    {
      s << indent << "  O_T_EE_d[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.O_T_EE_d[i]);
    }
    s << indent << "F_T_EE[]" << std::endl;
    for (size_t i = 0; i < v.F_T_EE.size(); ++i)
    {
      s << indent << "  F_T_EE[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.F_T_EE[i]);
    }
    s << indent << "EE_T_K[]" << std::endl;
    for (size_t i = 0; i < v.EE_T_K.size(); ++i)
    {
      s << indent << "  EE_T_K[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.EE_T_K[i]);
    }
    s << indent << "m_ee: ";
    Printer<double>::stream(s, indent + "  ", v.m_ee);
    s << indent << "I_ee[]" << std::endl;
    for (size_t i = 0; i < v.I_ee.size(); ++i)
    {
      s << indent << "  I_ee[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.I_ee[i]);
    }
    s << indent << "F_x_Cee[]" << std::endl;
    for (size_t i = 0; i < v.F_x_Cee.size(); ++i)
    {
      s << indent << "  F_x_Cee[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.F_x_Cee[i]);
    }
    s << indent << "m_load: ";
    Printer<double>::stream(s, indent + "  ", v.m_load);
    s << indent << "I_load[]" << std::endl;
    for (size_t i = 0; i < v.I_load.size(); ++i)
    {
      s << indent << "  I_load[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.I_load[i]);
    }
    s << indent << "F_x_Cload[]" << std::endl;
    for (size_t i = 0; i < v.F_x_Cload.size(); ++i)
    {
      s << indent << "  F_x_Cload[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.F_x_Cload[i]);
    }
    s << indent << "m_total: ";
    Printer<double>::stream(s, indent + "  ", v.m_total);
    s << indent << "I_total[]" << std::endl;
    for (size_t i = 0; i < v.I_total.size(); ++i)
    {
      s << indent << "  I_total[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.I_total[i]);
    }
    s << indent << "F_x_Ctotal[]" << std::endl;
    for (size_t i = 0; i < v.F_x_Ctotal.size(); ++i)
    {
      s << indent << "  F_x_Ctotal[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.F_x_Ctotal[i]);
    }
    s << indent << "elbow[]" << std::endl;
    for (size_t i = 0; i < v.elbow.size(); ++i)
    {
      s << indent << "  elbow[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.elbow[i]);
    }
    s << indent << "elbow_d[]" << std::endl;
    for (size_t i = 0; i < v.elbow_d.size(); ++i)
    {
      s << indent << "  elbow_d[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.elbow_d[i]);
    }
    s << indent << "elbow_c[]" << std::endl;
    for (size_t i = 0; i < v.elbow_c.size(); ++i)
    {
      s << indent << "  elbow_c[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.elbow_c[i]);
    }
    s << indent << "delbow_c[]" << std::endl;
    for (size_t i = 0; i < v.delbow_c.size(); ++i)
    {
      s << indent << "  delbow_c[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.delbow_c[i]);
    }
    s << indent << "ddelbow_c[]" << std::endl;
    for (size_t i = 0; i < v.ddelbow_c.size(); ++i)
    {
      s << indent << "  ddelbow_c[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.ddelbow_c[i]);
    }
    s << indent << "tau_J[]" << std::endl;
    for (size_t i = 0; i < v.tau_J.size(); ++i)
    {
      s << indent << "  tau_J[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.tau_J[i]);
    }
    s << indent << "tau_J_d[]" << std::endl;
    for (size_t i = 0; i < v.tau_J_d.size(); ++i)
    {
      s << indent << "  tau_J_d[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.tau_J_d[i]);
    }
    s << indent << "dtau_J[]" << std::endl;
    for (size_t i = 0; i < v.dtau_J.size(); ++i)
    {
      s << indent << "  dtau_J[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.dtau_J[i]);
    }
    s << indent << "q[]" << std::endl;
    for (size_t i = 0; i < v.q.size(); ++i)
    {
      s << indent << "  q[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.q[i]);
    }
    s << indent << "q_d[]" << std::endl;
    for (size_t i = 0; i < v.q_d.size(); ++i)
    {
      s << indent << "  q_d[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.q_d[i]);
    }
    s << indent << "dq[]" << std::endl;
    for (size_t i = 0; i < v.dq.size(); ++i)
    {
      s << indent << "  dq[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.dq[i]);
    }
    s << indent << "dq_d[]" << std::endl;
    for (size_t i = 0; i < v.dq_d.size(); ++i)
    {
      s << indent << "  dq_d[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.dq_d[i]);
    }
    s << indent << "ddq_d[]" << std::endl;
    for (size_t i = 0; i < v.ddq_d.size(); ++i)
    {
      s << indent << "  ddq_d[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.ddq_d[i]);
    }
    s << indent << "joint_contact[]" << std::endl;
    for (size_t i = 0; i < v.joint_contact.size(); ++i)
    {
      s << indent << "  joint_contact[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_contact[i]);
    }
    s << indent << "cartesian_contact[]" << std::endl;
    for (size_t i = 0; i < v.cartesian_contact.size(); ++i)
    {
      s << indent << "  cartesian_contact[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.cartesian_contact[i]);
    }
    s << indent << "joint_collision[]" << std::endl;
    for (size_t i = 0; i < v.joint_collision.size(); ++i)
    {
      s << indent << "  joint_collision[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_collision[i]);
    }
    s << indent << "cartesian_collision[]" << std::endl;
    for (size_t i = 0; i < v.cartesian_collision.size(); ++i)
    {
      s << indent << "  cartesian_collision[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.cartesian_collision[i]);
    }
    s << indent << "tau_ext_hat_filtered[]" << std::endl;
    for (size_t i = 0; i < v.tau_ext_hat_filtered.size(); ++i)
    {
      s << indent << "  tau_ext_hat_filtered[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.tau_ext_hat_filtered[i]);
    }
    s << indent << "O_F_ext_hat_K[]" << std::endl;
    for (size_t i = 0; i < v.O_F_ext_hat_K.size(); ++i)
    {
      s << indent << "  O_F_ext_hat_K[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.O_F_ext_hat_K[i]);
    }
    s << indent << "K_F_ext_hat_K[]" << std::endl;
    for (size_t i = 0; i < v.K_F_ext_hat_K.size(); ++i)
    {
      s << indent << "  K_F_ext_hat_K[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.K_F_ext_hat_K[i]);
    }
    s << indent << "O_dP_EE_d[]" << std::endl;
    for (size_t i = 0; i < v.O_dP_EE_d.size(); ++i)
    {
      s << indent << "  O_dP_EE_d[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.O_dP_EE_d[i]);
    }
    s << indent << "O_T_EE_c[]" << std::endl;
    for (size_t i = 0; i < v.O_T_EE_c.size(); ++i)
    {
      s << indent << "  O_T_EE_c[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.O_T_EE_c[i]);
    }
    s << indent << "O_dP_EE_c[]" << std::endl;
    for (size_t i = 0; i < v.O_dP_EE_c.size(); ++i)
    {
      s << indent << "  O_dP_EE_c[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.O_dP_EE_c[i]);
    }
    s << indent << "O_ddP_EE_c[]" << std::endl;
    for (size_t i = 0; i < v.O_ddP_EE_c.size(); ++i)
    {
      s << indent << "  O_ddP_EE_c[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.O_ddP_EE_c[i]);
    }
    s << indent << "theta[]" << std::endl;
    for (size_t i = 0; i < v.theta.size(); ++i)
    {
      s << indent << "  theta[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.theta[i]);
    }
    s << indent << "dtheta[]" << std::endl;
    for (size_t i = 0; i < v.dtheta.size(); ++i)
    {
      s << indent << "  dtheta[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.dtheta[i]);
    }
    s << indent << "current_errors: ";
    s << std::endl;
    Printer< ::franka_interface_msgs::Errors_<ContainerAllocator> >::stream(s, indent + "  ", v.current_errors);
    s << indent << "last_motion_errors: ";
    s << std::endl;
    Printer< ::franka_interface_msgs::Errors_<ContainerAllocator> >::stream(s, indent + "  ", v.last_motion_errors);
    s << indent << "control_command_success_rate: ";
    Printer<double>::stream(s, indent + "  ", v.control_command_success_rate);
    s << indent << "robot_mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.robot_mode);
    s << indent << "robot_time: ";
    Printer<double>::stream(s, indent + "  ", v.robot_time);
    s << indent << "gripper_width: ";
    Printer<double>::stream(s, indent + "  ", v.gripper_width);
    s << indent << "gripper_max_width: ";
    Printer<double>::stream(s, indent + "  ", v.gripper_max_width);
    s << indent << "gripper_is_grasped: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gripper_is_grasped);
    s << indent << "gripper_temperature: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.gripper_temperature);
    s << indent << "gripper_time: ";
    Printer<double>::stream(s, indent + "  ", v.gripper_time);
    s << indent << "is_fresh: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_fresh);
  }
};

} // namespace message_operations
} // namespace ros

#endif // FRANKA_INTERFACE_MSGS_MESSAGE_ROBOTSTATE_H
